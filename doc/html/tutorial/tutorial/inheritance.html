<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Inheritance</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../index.html" title="Boost.Python Tutorial">
<link rel="up" href="exposing.html" title="Exposing Classes">
<link rel="prev" href="class_properties.html" title="Class Properties">
<link rel="next" href="class_virtual_functions.html" title="Class Virtual Functions">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../images/boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="class_properties.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="exposing.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="class_virtual_functions.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="tutorial.inheritance"></a>Inheritance</h3></div></div></div>
<p>
        In the previous examples, we dealt with classes that are not polymorphic.
        This is not often the case. Much of the time, we will be wrapping polymorphic
        classes and class hierarchies related by inheritance. We will often have
        to write Boost.Python wrappers for classes that are derived from abstract
        base classes.
      </p>
<p>
        Consider this trivial inheritance structure:
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">Base</span> <span class="special">{</span> <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">Base</span><span class="special">();</span> <span class="special">};</span>
<span class="keyword">struct</span> <span class="identifier">Derived</span> <span class="special">:</span> <span class="identifier">Base</span> <span class="special">{};</span>
</pre>
<p>
        And a set of C++ functions operating on <code class="literal">Base</code> and <code class="literal">Derived</code>
        object instances:
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">b</span><span class="special">(</span><span class="identifier">Base</span><span class="special">*);</span>
<span class="keyword">void</span> <span class="identifier">d</span><span class="special">(</span><span class="identifier">Derived</span><span class="special">*);</span>
<span class="identifier">Base</span><span class="special">*</span> <span class="identifier">factory</span><span class="special">()</span> <span class="special">{</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="identifier">Derived</span><span class="special">;</span> <span class="special">}</span>
</pre>
<p>
        We've seen how we can wrap the base class <code class="literal">Base</code>:
      </p>
<pre class="programlisting"><span class="identifier">class_</span><span class="special">&lt;</span><span class="identifier">Base</span><span class="special">&gt;(</span><span class="string">"Base"</span><span class="special">)</span>
    <span class="comment">/*...*/</span>
    <span class="special">;</span>
</pre>
<p>
        Now we can inform Boost.Python of the inheritance relationship between <code class="literal">Derived</code>
        and its base class <code class="literal">Base</code>. Thus:
      </p>
<pre class="programlisting"><span class="identifier">class_</span><span class="special">&lt;</span><span class="identifier">Derived</span><span class="special">,</span> <span class="identifier">bases</span><span class="special">&lt;</span><span class="identifier">Base</span><span class="special">&gt;</span> <span class="special">&gt;(</span><span class="string">"Derived"</span><span class="special">)</span>
    <span class="comment">/*...*/</span>
    <span class="special">;</span>
</pre>
<p>
        Doing so, we get some things for free:
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
            Derived automatically inherits all of Base's Python methods (wrapped
            C++ member functions)
          </li>
<li class="listitem">
            <span class="bold"><strong>If</strong></span> Base is polymorphic, <code class="literal">Derived</code>
            objects which have been passed to Python via a pointer or reference to
            <code class="literal">Base</code> can be passed where a pointer or reference to
            <code class="literal">Derived</code> is expected.
          </li>
</ol></div>
<p>
        Now, we will expose the C++ free functions <code class="literal">b</code> and <code class="literal">d</code>
        and <code class="literal">factory</code>:
      </p>
<pre class="programlisting"><span class="identifier">def</span><span class="special">(</span><span class="string">"b"</span><span class="special">,</span> <span class="identifier">b</span><span class="special">);</span>
<span class="identifier">def</span><span class="special">(</span><span class="string">"d"</span><span class="special">,</span> <span class="identifier">d</span><span class="special">);</span>
<span class="identifier">def</span><span class="special">(</span><span class="string">"factory"</span><span class="special">,</span> <span class="identifier">factory</span><span class="special">);</span>
</pre>
<p>
        Note that free function <code class="literal">factory</code> is being used to generate
        new instances of class <code class="literal">Derived</code>. In such cases, we use
        <code class="literal">return_value_policy&lt;manage_new_object&gt;</code> to instruct
        Python to adopt the pointer to <code class="literal">Base</code> and hold the instance
        in a new Python <code class="literal">Base</code> object until the the Python object
        is destroyed. We will see more of Boost.Python <a class="link" href="../">call
        policies</a> later.
      </p>
<pre class="programlisting"><span class="comment">// Tell Python to take ownership of factory's result</span>
<span class="identifier">def</span><span class="special">(</span><span class="string">"factory"</span><span class="special">,</span> <span class="identifier">factory</span><span class="special">,</span>
    <span class="identifier">return_value_policy</span><span class="special">&lt;</span><span class="identifier">manage_new_object</span><span class="special">&gt;());</span>
</pre>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2002-2005 Joel
      de Guzman, David Abrahams<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at [@http://www.boost.org/LICENSE_1_0.txt]
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="class_properties.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="exposing.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="class_virtual_functions.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
